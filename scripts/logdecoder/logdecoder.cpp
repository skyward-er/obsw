/* Copyright (c) 2025 Skyward Experimental Rocketry
 * Author: Niccol√≤ Betto
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <Groundstation/Automated/Actuators/ActuatorsData.h>
#include <Groundstation/Automated/PinHandler/PinData.h>
#include <Groundstation/Automated/SMA/SMAData.h>
#include <Groundstation/LyraGS/Radio/RadioData.h>
#include <Main/PinHandler/PinData.h>
#include <Main/Sensors/SensorsData.h>
#include <Main/StateMachines/ABKController/ABKControllerData.h>
#include <Main/StateMachines/ADAController/ADAControllerData.h>
#include <Main/StateMachines/FlightModeManager/FlightModeManagerData.h>
#include <Main/StateMachines/MEAController/MEAControllerData.h>
#include <Main/StateMachines/NASController/NASControllerData.h>
#include <Motor/Actuators/ActuatorsData.h>
#include <Motor/Sensors/SensorsData.h>
#include <Payload/PinHandler/PinData.h>
#include <Payload/Sensors/SensorData.h>
#include <Payload/StateMachines/FlightModeManager/FlightModeManagerData.h>
#include <Payload/StateMachines/NASController/NASControllerData.h>
#include <Payload/StateMachines/WingController/WingControllerData.h>
#include <Payload/Wing/WingAlgorithmData.h>
#include <Payload/Wing/WingTargetPositionData.h>
#include <RIGv2/Actuators/ActuatorsData.h>
#include <RIGv2/Sensors/SensorsData.h>
#include <RIGv2/StateMachines/GroundModeManager/GroundModeManagerData.h>
#include <RIGv2/StateMachines/TARS1/TARS1Data.h>
#include <RIGv2/StateMachines/TARS3/TARS3Data.h>
#include <algorithms/MEA/MEAData.h>
#include <fmt/format.h>
#include <algorithms/Propagator/PropagatorData.h>
#include <logger/Deserializer.h>
#include <logger/LogTypes.h>
#include <logger/Logger.h>
#include <tscpp/stream.h>
#include <Groundstation/Automated/LogSniffing.h>


#include <chrono>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <string_view>

/**
 * @brief Binary log file decoder.
 *
 * This program deserializes binary log files generated by the Skyward boards
 * to CSV files, each containing the data of a specific type.
 */

using namespace std::chrono;
using namespace tscpp;
using namespace Boardcore;

void registerTypes(Deserializer& ds)
{
    // Register all Boardcore types
    LogTypes::registerTypes(ds);

    // Custom types
    // Main
    ds.registerType<Main::FlightModeManagerStatus>();
    ds.registerType<Main::NASControllerStatus>();
    ds.registerType<Main::MEAControllerStatus>();
    ds.registerType<Main::ADAControllerSampleData>();
    ds.registerType<Main::ADAControllerStatus>();
    ds.registerType<Main::ABKControllerStatus>();
    ds.registerType<Main::PinChangeData>();
    ds.registerType<Main::StaticPressure0Data>();
    ds.registerType<Main::StaticPressure1Data>();
    ds.registerType<Main::StaticPressure2Data>();
    ds.registerType<Main::DplBayPressureData>();
    ds.registerType<Main::LSM6DSRX0Data>();
    ds.registerType<Main::LSM6DSRX1Data>();
    ds.registerType<Main::LIS2MDLExternalData>();
    ds.registerType<Main::CalibrationData>();

    // Motor
    ds.registerType<Motor::TopTankPressureData>();
    ds.registerType<Motor::BottomTankPressureData>();
    ds.registerType<Motor::CCPressureData>();
    ds.registerType<Motor::ActuatorsData>();

    // Payload
    ds.registerType<Payload::FlightModeManagerStatus>();
    ds.registerType<Payload::NASControllerStatus>();
    ds.registerType<Payload::WingControllerStatus>();
    ds.registerType<Payload::StaticPressureData>();
    ds.registerType<Payload::DynamicPressureData>();
    ds.registerType<Payload::SensorCalibrationData>();
    ds.registerType<Payload::PinChangeData>();
    ds.registerType<Payload::WingControllerAlgorithmData>();
    ds.registerType<Payload::WingAlgorithmData>();
    ds.registerType<Payload::WingTargetPositionData>();
    ds.registerType<Payload::EarlyManeuversActiveTargetData>();

    // RIGv2
    ds.registerType<RIGv2::ADC1Data>();
    ds.registerType<RIGv2::ADC2Data>();
    ds.registerType<RIGv2::TC1Data>();
    ds.registerType<RIGv2::OxVesselWeightData>();
    ds.registerType<RIGv2::RocketWeightData>();
    ds.registerType<RIGv2::OxTankWeightData>();
    ds.registerType<RIGv2::OxVesselPressureData>();
    ds.registerType<RIGv2::OxFillingPressureData>();
    ds.registerType<RIGv2::N2Vessel1PressureData>();
    ds.registerType<RIGv2::N2Vessel2PressureData>();
    ds.registerType<RIGv2::N2FillingPressureData>();
    ds.registerType<RIGv2::OxTankPressureData>();
    ds.registerType<RIGv2::N2TankPressureData>();
    ds.registerType<RIGv2::ActuatorsData>();
    ds.registerType<RIGv2::GroundModeManagerData>();
    ds.registerType<RIGv2::Tars1ActionData>();
    ds.registerType<RIGv2::Tars1SampleData>();
    ds.registerType<RIGv2::Tars3ActionData>();
    ds.registerType<RIGv2::Tars3SampleData>();

    // Groundstation (ARP)
    ds.registerType<Antennas::StepperXData>();
    ds.registerType<Antennas::StepperYData>();
    ds.registerType<VN300Data>();
    ds.registerType<NASState>();
    ds.registerType<PropagatorState>();
    ds.registerType<AntennaAnglesLog>();
    ds.registerType<GPSData>();
    ds.registerType<Antennas::SMAStatus>();
    ds.registerType<Antennas::PinChangeData>();
    ds.registerType<LyraGS::MainRadioLog>();
    ds.registerType<Antennas::LogSniffing();
}

// cppcheck-suppress passedByValue
void printUsage(std::string_view cmdName)
{
    std::cerr
        << "Skyward Log Decoder\n"
        << "Usage: " << cmdName << " [OPTIONS] [FILES]\n\n"
        << "FILES may be a mix of files and directories.\n"
        << "With no FILES specified, deserialize all log files in the current "
           "directory.\n\n"
        << "Options:\n"
        << "  -h, --help\t\tDisplay this help and exit\n";
}

bool deserialize(const std::filesystem::path& file)
{
    std::cout << "Deserializing " << file << "\n";

    auto fileAbsPath = std::filesystem::absolute(file);

    // Deserializer requires to be in the directory of the file
    std::filesystem::current_path(fileAbsPath.parent_path());

    // Deserializer requires the filename only, not the path
    Deserializer d(fileAbsPath.filename());
    registerTypes(d);

    auto start  = steady_clock::now();
    bool result = d.deserialize();
    auto end    = steady_clock::now();

    if (result)
    {
        std::cout << "Successfully deserialized " << file << " in "
                  << duration_cast<milliseconds>(end - start) << "\n";
    }
    else
    {
        std::cerr << "Failed to deserialize " << file << "\n";
    }

    return result;
}

bool deserializeDirectory(const std::filesystem::path& directory)
{
    std::cout << "Deserializing all log files in " << directory << "\n";

    if (!std::filesystem::is_directory(directory))
    {
        std::cerr << directory << " is not a directory\n";
        return false;
    }

    // cd to the directory to search for log files
    std::filesystem::current_path(directory);

    bool success = true;
    int count    = 0;
    for (int i = 0; i < Logger::getMaxFilenameNumber(); i++)
    {
        auto file = fmt::format("log{:02d}.dat", i);
        if (!std::filesystem::is_regular_file(file))
            continue;

        count++;
        success &= deserialize(file);
    }

    if (count == 0)
        std::cerr << "No log files found in " << directory << "\n";

    return success;
}

int main(int argc, char* argv[])
{
    auto exeName = argv[0];

    // A list of files and directories to deserialize
    std::vector<std::filesystem::path> files;

    // Parse arguments
    for (int i = 1; i < argc; i++)
    {
        auto arg = std::string_view(argv[i]);

        // Help option
        if (arg == "-h" || arg == "--help")
        {
            printUsage(exeName);
            return 0;
        }

        // Invalid option
        if (arg.starts_with("-"))
        {
            std::cerr << exeName << ": invalid option "
                      << std::quoted(arg, '\'') << "\n"
                      << "Try '" << exeName
                      << " --help' for more information.\n";
            return 1;
        }

        // File or directory argument
        auto file = std::filesystem::path(arg);
        if (std::filesystem::exists(arg))
        {
            files.push_back(file);
        }
        else
        {
            std::cerr << "File " << file << " does not exist\n";
            return 1;
        }
    }

    // If no files are provided, deserialize all log files in the current dir
    if (files.empty())
    {
        std::cout << "No files specified, deserializing all log files in "
                     "current directory\n";
        files.push_back(std::filesystem::current_path());
    }

    bool success = true;
    // Deserialize all files
    for (const auto& file : files)
        if (std::filesystem::is_directory(file))
            success &= deserializeDirectory(file);
        else
            success &= deserialize(file);

    if (success)
    {
        std::cout << "Done\n";
        return 0;
    }
    else
    {
        std::cerr << "Error: one or more files failed to deserialize\n";
        return 1;
    }
}
